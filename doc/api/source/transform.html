<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
 * Storing Transform Matrix
 * ===========================================
 * Last updated September 2011 by Simon Sarris
 * www.simonsarris.com
 * sarris@acm.org
 *
 * Free to use and distribute at will
 * So long as you are nice to people, etc
 *
 * (slightly modified by shaman.sir@gmail.com) */

// Simple class for keeping track of the current transformation matrix

// For instance:
//    var t = new Transform();
//    t.rotate(5);
//    t.apply(ctx);

// Is equivalent to:
//    ctx.rotate(5);

// But now you can retrieve it :)

// Remember that this does not account for any CSS transforms applied to the canvas

// TODO: use somewhat closer to AfineTransform from

function Transform() {
  this.m = [1,0,0,1,0,0];
}

Transform.prototype.reset = function() {
  this.m = [1,0,0,1,0,0];
};

Transform.prototype.multiply = function(matrix) {
  var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
  var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];

  var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
  var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];

  var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
  var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];

  this.m[0] = m11;
  this.m[1] = m12;
  this.m[2] = m21;
  this.m[3] = m22;
  this.m[4] = dx;
  this.m[5] = dy;
};

Transform.prototype.invert = function() {
  var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
  var m0 = this.m[3] * d;
  var m1 = -this.m[1] * d;
  var m2 = -this.m[2] * d;
  var m3 = this.m[0] * d;
  var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
  var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
  this.m[0] = m0;
  this.m[1] = m1;
  this.m[2] = m2;
  this.m[3] = m3;
  this.m[4] = m4;
  this.m[5] = m5;
};

Transform.prototype.rotate = function(rad) {
  var c = Math.cos(rad);
  var s = Math.sin(rad);
  var m11 = this.m[0] * c + this.m[2] * s;
  var m12 = this.m[1] * c + this.m[3] * s;
  var m21 = this.m[0] * -s + this.m[2] * c;
  var m22 = this.m[1] * -s + this.m[3] * c;
  this.m[0] = m11;
  this.m[1] = m12;
  this.m[2] = m21;
  this.m[3] = m22;
};

Transform.prototype.rotateDegrees = function(angle) {
  var rad = angle * Math.PI / 180;
  var c = Math.cos(rad);
  var s = Math.sin(rad);
  var m11 = this.m[0] * c + this.m[2] * s;
  var m12 = this.m[1] * c + this.m[3] * s;
  var m21 = this.m[0] * -s + this.m[2] * c;
  var m22 = this.m[1] * -s + this.m[3] * c;
  this.m[0] = m11;
  this.m[1] = m12;
  this.m[2] = m21;
  this.m[3] = m22;
};

Transform.prototype.translate = function(x, y) {
  this.m[4] += this.m[0] * x + this.m[2] * y;
  this.m[5] += this.m[1] * x + this.m[3] * y;
};

Transform.prototype.scale = function(sx, sy) {
  this.m[0] *= sx;
  this.m[1] *= sx;
  this.m[2] *= sy;
  this.m[3] *= sy;
};

Transform.prototype.transformPoint = function(x, y) {
  return { x: (x * this.m[0] + y * this.m[2] + this.m[4]),
           y: (x * this.m[1] + y * this.m[3] + this.m[5]) };
};

Transform.prototype.transformPointInverse = function(x, y) {
  var t0 = (this.m[0] !== 0) ? (x / this.m[0]) : 0,
      t1 = (this.m[1] !== 0) ? (x / this.m[1]) : 0,
      t2 = (this.m[2] !== 0) ? (y / this.m[2]) : 0,
      t3 = (this.m[3] !== 0) ? (y / this.m[3]) : 0;
  return { x: (t0 - t2 - this.m[4]),
           y: (t1 - t3 - this.m[5]) };
};

// customized methods

Transform.prototype.shear = function(hx, hy) {
  var m11 = this.m[0] + this.m[2] * hy;
  var m12 = this.m[1] + this.m[3] * hy;
  var m21 = this.m[0] * hx + this.m[2];
  var m22 = this.m[1] * hx + this.m[3];
  this.m[0] = m11;
  this.m[1] = m12;
  this.m[2] = m21;
  this.m[3] = m22;
};

Transform.prototype.apply = function(ctx) {
  var m = this.m;
  ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
};

Transform.prototype.clone = function() {
  var cl = new Transform();
  cl.m[0] = this.m[0];
  cl.m[1] = this.m[1];
  cl.m[2] = this.m[2];
  cl.m[3] = this.m[3];
  cl.m[4] = this.m[4];
  cl.m[5] = this.m[5];
  return cl;
};

Transform.prototype.inverted = function() {
  var clone = this.clone();
  clone.invert();
  return clone;
};

/* TODO:?
Transform.prototype.extract = function() {

} */

if (typeof module !== &#39;undefined&#39;) module.exports = Transform;
</pre>
</body>
</html>
